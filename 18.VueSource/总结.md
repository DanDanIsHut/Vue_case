# 总结

## 1. 数据代理：

将 data 中数据代理 this 上使用，使用方便

遍历所有 data 数据，对每一个 data 属性进行数据代理
数据代理就是通过 Object.defineProperty 方法重新定义 data 数据，定义在 this（实例）上
定义时会有属性描述符 get、set
当读取 this 上的数据时，会调用 get 方法，读取的实际是原 data 数据的值
当设置 this 上的数据时，会调用 set 方法，设置的实际是原 data 数据的值

## 2. 数据劫持

将原 data 进行重新定义，定义成响应式（注意：响应式联系不是在这里产生的）

遍历原 data 数据，通过 defineReactive 方法将原 data 数据中所有属性定义成响应式
通过 Object.defineProperty 方法重新定义属性的 get 和 set 方法
此时每一个 data 数据的属性会生成 dep 对象，通过闭包的方式保存在 get 和 set 方法中
最终，会通过递归调用的方式确保 data 中所有属性都定义成响应式

## 3. 模板解析:

解析元素上的指令属性和插值语法

1. 将节点装换成文档碎片节点

   - 创建了文档碎片节点
   - 通过 while 遍历将 el 的子节点插入文档碎片节点中
   - 返回文档碎片节点

2. 编译模板

   - 提取文档碎片中所有子节点（childNodes）
   - 对所有子节点进行遍历，一一处理
   - 提取子节点的文本内容

     - 判断是否元素节点

       - 如果是提取元素节点的所有属性节点，进行遍历
       - 提取属性节点的属性名，判断是否是指令属性（v-）
         - 如果是在判断是否是事件指令（on）
           - 如果是事件指令：给当前元素绑定事件，设置回调函数
             - 事件名从指令属性中截取
             - 回调函数中从 methods 中获取
             - 回调函数通过 bind 方法改变 this 指向为 vm 实例
         - 还是一般指令
           - 最终会找到相应指令的 updater 方法，去更新 DOM 元素
             - 比如：v-text，找到 textUpdater 更新方法，最终通过 textContent 属性更新元素文本内容
             - v-html,找到 htmlUpdater 更新方法，最终通过 innerHTML 属性更新元素文本内容
         - 指令解析完成，会从元素上被移除掉

     - 进行判断是否是文本节点，并且里面的文本内容满足插值语法
       - 如果是，就需要对插值语法进行解析
         - 内部调用多个方法，最终取出一个用来更新 DOM 元素的 updater 函数
         - 从 vm 上读取表达式的值
         - 调用 updater 方法更新元素的 textContent 为表达式的值
         - 到此插值语法就解析完毕了
         - 插值语法解析后面和 v-text 指令解析是一致的，最终调用 textUpdater 更新方法，去更新 DOM 元素

   - 最终，都要对当前子节点的所有子节点进行递归遍历，确保所有节点都进行了编译

3. 将编译后的模板放入 el 中生效

## 4. 响应式

在模板解析的时候，如果解析的是插值语法或非事件以外的指令，最终回来一个 bind 方法，
在内部会 new Watcher
watcher 中会接受到用来更新用户界面的 updater 方法保存在 cb 中
同时，会读取表达式的值，读取值的时候会触发数据劫持阶段给数据绑定的 get 方法
在 get 方法中会调用 dep.depend()建立 dep 和 watcher 之间的联系
dep 中会保存 watcher
watcher 会保存 dep

所有响应式 data 数据都有自己的 dep
所有插值语法或非事件以外的指令都有自己的 watcher
它们之间根据联系互相保存

将来，当用户更新 data 数据时，首先触发数据代理的 set 方法，里面更新时原 data 数据
然后触发数据劫持的 set 方法，这个方法中就会更新数据，同时调用 dep.notify 方法来
通知当前 dep 保存的所有 watcher 去更新界面（因为每个 watcher 中都保存了 cb）
所以，达到数据更新了，用户界面也更新了，响应式

## 5. v-model 原理

v-model 作为指令解析

给元素设置 value 属性，值就是表达式的值 model --> view
绑定了 input 事件，将来输入数据时可以收集到数据，更新相应表达式值 view --> model

从而达到数据的双向绑定原理
